"""Script containing the base scenario kernel class."""
from copy import deepcopy
import json
import os
from flow.core.kernel.scenario.base import KernelScenario

# length of vehicles in the network, in meters
VEHICLE_LENGTH = 5


class AimsunKernelScenario(KernelScenario):
    """Base scenario kernel.

    This kernel subclass is responsible for generating any simulation-specific
    components needed to simulate a traffic network. This may include network
    creating configuration files that support the generating of certain traffic
    networks in a simulator (e.g. sumo), or may be as simple as passing network
    features from the scenario class (see flow/scenarios/base_scenario.py) and
    transferring them to the simulator kernel later on.

    In addition to generating files for network initialization, the scenario
    kernel performs two auxiliary tasks:

    * State acquisition: The scenario kernel contains several methods that can
      be used to acquire state information on the properties of the network
      that is being simulated, e.g. the number of lanes on an edge, the length
      of an edge, the available routes from a starting position, etc... If, for
      example, you would like to determine the maximum speed a vehicle can
      travel within the network, this can be done by calling the following
      command:

        >>> from flow.envs.base_env import Env
        >>> env = Env(...)
        >>> max_speed = env.k.scenario.max_speed()

      All relevant methods may be found within the Flow documentation.

    * Methods for generating initial vehicle positions: Initial vehicle
      positions are generated by the abstract scenario kernel, and may be
      overridden by the network generated from a flow.scenarios.Scenario object
      if the spacing in ``initial_config`` is set to random. Default initial
      positions include uniform starting positions (where all vehicles are
      equally spacing) or random starting positions (limited by some min_gap).
      For more details on how to augment the starting position of vehicles,
      see:  # TODO: create tutorial
    """

    def __init__(self, master_kernel):
        """Instantiate the base scenario kernel.

        Parameters
        ----------
        master_kernel : flow.core.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        """
        KernelScenario.__init__(self, master_kernel)

        self.master_kernel = master_kernel
        self.kernel_api = None
        self.network = None

        self.edges = None
        self.nodes = None
        self.types = None
        self.connections = None
        self.routes = None
        self.net_params = None
        self._edges = None
        self._edge_list = None
        self._junction_list = None
        self.__max_speed = None
        self.__length = None

    def generate_network(self, scenario):
        self.network = scenario
        self.edges = scenario.edges
        self.routes = scenario.routes
        self.nodes = scenario.nodes
        self.types = scenario.types
        self.connections = scenario.connections
        self.net_params = scenario.net_params

        output = {
            "edges": self.edges,
            "nodes": self.nodes,
            "types": self.types,
            "connections": self.connections
        }

        cur_dir = os.path.dirname(__file__)
        # TODO: add current time
        with open(os.path.join(cur_dir, 'data.json'), 'w') as outfile:
            json.dump(output, outfile, sort_keys=True, indent=4)

        # merge types into edges
        for i in range(len(self.edges)):
            if 'type' in self.edges[i]:
                for typ in self.types:
                    if typ['id'] == self.edges[i]['type']:
                        new_dict = deepcopy(typ)
                        new_dict.pop("id")
                        self.edges[i].update(new_dict)
                    break

        self._edges = {}
        for edge in self.edges:
            edge_name = edge['id']
            self._edges[edge_name] = {}
            del edge['id']
            self._edges[edge_name] = edge

        # list of edges and internal links (junctions)
        self._edge_list = [
            edge_id for edge_id in self._edges.keys() if edge_id[0] != ':'
        ]
        self._junction_list = list(
            set(self._edges.keys()) - set(self._edge_list))

        # maximum achievable speed on any edge in the network
        self.__max_speed = max(
            self.speed_limit(edge) for edge in self.get_edge_list())

        # length of the network, or the portion of the network in
        # which cars are meant to be distributed
        print([
            self.edge_length(edge_id) for edge_id in self.get_edge_list()
        ])
        self.__length = sum(
            self.edge_length(edge_id) for edge_id in self.get_edge_list()
        )

        # parameters to be specified under each unique subclass's
        # __init__() function
        self.edgestarts = self.network.edge_starts

        # if no edge_starts are specified, generate default values to be used
        # by the "get_x" method
        if self.edgestarts is None:
            length = 0
            self.edgestarts = []
            for edge_id in sorted(self._edge_list):
                # the current edge starts where the last edge ended
                self.edgestarts.append((edge_id, length))
                # increment the total length of the network with the length of
                # the current edge
                length += self._edges[edge_id]['length']

        # these optional parameters need only be used if "no-internal-links"
        # is set to "false" while calling sumo's netconvert function
        self.internal_edgestarts = self.network.internal_edge_starts
        self.intersection_edgestarts = self.network.intersection_edge_starts

        # in case the user did not write the intersection edge-starts in
        # internal edge-starts as well (because of redundancy), merge the two
        # together
        self.internal_edgestarts += self.intersection_edgestarts
        seen = set()
        self.internal_edgestarts = \
            [item for item in self.internal_edgestarts
             if item[1] not in seen and not seen.add(item[1])]
        self.internal_edgestarts_dict = dict(self.internal_edgestarts)

        # total_edgestarts and total_edgestarts_dict contain all of the above
        # edges, with the former being ordered by position
        if self.network.net_params.no_internal_links:
            self.total_edgestarts = self.edgestarts
        else:
            self.total_edgestarts = self.edgestarts + self.internal_edgestarts
        self.total_edgestarts.sort(key=lambda tup: tup[1])

        self.total_edgestarts_dict = dict(self.total_edgestarts)

        # specify routes vehicles can take  # TODO: move into a method
        self.rts = self.network.routes

    def pass_api(self, kernel_api):
        """Acquire the kernel api that was generated by the simulation kernel.

        Parameters
        ----------
        kernel_api : any
            an API that may be used to interact with the simulator
        """
        self.kernel_api = kernel_api

    def update(self, reset):
        """Update the scenario with current state information.

        Since scenarios are generally static, this will most likely not include
        any actions being performed. This is primarily here for consistency
        with other sub-kernels.

        Parameters
        ----------
        reset : bool
            specifies whether the simulator was reset in the last simulation
            step
        """
        pass

    def close(self):
        """Close the scenario."""
        # delete the json file that was used to read the scenario data
        cur_dir = os.path.dirname(__file__)
        os.remove(os.path.join(cur_dir, 'data.json'))

    ###########################################################################
    #                        State acquisition methods                        #
    ###########################################################################

    def edge_length(self, edge_id):
        """Return the length of a given edge/junction.

        Return -1001 if edge not found.
        """
        try:
            return self._edges[edge_id]["length"]
        except KeyError:
            print('Error in edge length with key', edge_id)
            return -1001

    def length(self):
        """Return the total length of all junctions and edges."""
        return sum(self.edge_length(edge_id)
                   for edge_id in self.get_edge_list())

    def speed_limit(self, edge_id):
        """Return the speed limit of a given edge/junction.

        Return -1001 if edge not found.
        """
        try:
            return self._edges[edge_id]["speed"]
        except KeyError:
            print('Error in speed limit with key', edge_id)
            return -1001

    def max_speed(self):
        """Return the maximum achievable speed on any edge in the network."""
        return max(
            self.speed_limit(edge) for edge in self.get_edge_list())

    def num_lanes(self, edge_id):
        """Return the number of lanes of a given edge/junction.

        Return -1001 if edge not found.
        """
        try:
            return self._edges[edge_id]["numLanes"]
        except KeyError:
            print('Error in num lanes with key', edge_id)
            return -1001

    def get_edge_list(self):
        """Return the names of all edges in the network."""
        return [
            edge_id for edge_id in self._edges.keys() if edge_id[0] != ":"
        ]

    def get_junction_list(self):
        """Return the names of all junctions in the network."""
        return list(
            set(self._edges.keys()) - set(self._edge_list))

    def get_edge(self, x):  # TODO: maybe remove
        """Compute an edge and relative position from an absolute position.

        Parameters
        ----------
        x : float
            absolute position in network

        Returns
        -------
        edge position : tup
            1st element: edge name (such as bottom, right, etc.)
            2nd element: relative position on edge
        """
        for (edge, start_pos) in reversed(self.total_edgestarts):
            if x >= start_pos:
                return edge, x - start_pos

    def get_x(self, edge, position):  # TODO: maybe remove
        """Return the absolute position on the track.

        Parameters
        ----------
        edge : str
            name of the edge
        position : float
            relative position on the edge

        Returns
        -------
        absolute_position : float
            position with respect to some global reference
        """
        # if there was a collision which caused the vehicle to disappear,
        # return an x value of -1001
        if len(edge) == 0:
            return -1001

        if edge[0] == ":":
            try:
                return self.internal_edgestarts_dict[edge] + position
            except KeyError:
                # in case several internal links are being generalized for
                # by a single element (for backwards compatibility)
                edge_name = edge.rsplit("_", 1)[0]
                return self.total_edgestarts_dict.get(edge_name, -1001)
        else:
            return self.total_edgestarts_dict[edge] + position

    def next_edge(self, edge, lane):
        """Return the next edge/lane pair from the given edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs in front.
        """
        try:
            return self._connections["next"][edge][lane]
        except KeyError:
            return []

    def prev_edge(self, edge, lane):
        """Return the edge/lane pair right before this edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs behind.
        """
        try:
            return self._connections["prev"][edge][lane]
        except KeyError:
            return []

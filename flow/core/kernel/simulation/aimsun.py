"""Script containing the base simulation kernel class."""
from flow.core.kernel.simulation.base import KernelSimulation
import subprocess
import os
import socket

try:
    # Load user config if exists, else load default config
    import flow.config as config
except ImportError:
    import flow.config_default as config


class AimsunKernelSimulation(KernelSimulation):
    """Base simulation kernel.

    The simulation kernel is responsible for generating the simulation and
    passing to all other kernel the API that they can use to interact with the
    simulation.

    The simulation kernel is also responsible for advancing, resetting, and
    storing whatever simulation data is relevant.

    All methods in this class are abstract and must be overwritten by other
    child classes.
    """

    def __init__(self, master_kernel):
        """Initialize the simulation kernel.

        Parameters
        ----------
        master_kernel : flow.core.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        """
        KernelSimulation.__init__(self, master_kernel)

        self.master_kernel = master_kernel
        self.kernel_api = None
        self.sim_step = None

    def pass_api(self, kernel_api):
        """Acquire the kernel api that was generated by the simulation kernel.

        Parameters+
        ----------
        kernel_api : any
            an API that may be used to interact with the simulator
        """
        self.kernel_api = kernel_api

    def start_simulation(self, network, sim_params):
        """Start a simulation instance.

        network : any
            an object or variable that is meant to symbolize the network that
            is used during the simulation. For example, in the case of sumo
            simulations, this is (string) the path to the .sumo.cfg file.
        sim_params : flow.core.params.SumoParams  # FIXME: make ambiguous
            simulation-specific parameters
        """
        # FIXME: hack
        sim_params.port = 50005

        # save the simulation step size (for later use)
        self.sim_step = sim_params.sim_step

        # path to the Aimsun_Next binary
        aimsun_path = os.path.expanduser(config.AIMSUN_NEXT_PATH)

        # path to the supplementary file that is used to generate an aimsun
        # network from a template
        cur_dir = os.path.dirname(__file__)
        script_path = os.path.join(cur_dir, "../../../utils/aimsun.py")

        # start the aimsun process
        aimsun_call = [aimsun_path, "-script", script_path]

        # subprocess.Popen(aimsun_call)

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        connected = False
        num_tries = 0
        while not connected and num_tries < 100:
            num_tries += 1
            try:
                s.connect(('localhost', 9999))
                connected = True
            except Exception as e:
                print(
                    "Cannot connect to the server: {}".format(e))
                import time
                time.sleep(1)

        data = None
        while data is None:
            data = s.recv(2048)
        print(data.decode('utf-8'))

        # wait for a short period of time for the connection to be finalized
        import time
        time.sleep(1)

        # return conn
        return s

    def simulation_step(self):
        """Advance the simulation by one step.

        This is done in most cases by calling a relevant simulator API method.
        """
        order = 3  # 3: Stop simulation
        when = int(self.kernel_api.AKIGetCurrentSimulationTime())  # sim time
        self.kernel_api.ANGSetSimulationOrder(order, when)

        order = 0
        when = int(when + self.sim_step)
        # TODO this is risky since "when" should be integer
        self.kernel_api.ANGSetSimulationOrder(order, when)

    def update(self, reset):
        """Update the internal attributes of the simulation kernel.

        Any update operations are meant to support ease of simulation in
        current and future steps.

        Parameters
        ----------
        reset : bool
            specifies whether the simulator was reset in the last simulation
            step
        """
        pass

    def check_collision(self):
        """Determine if a collision occurred in the last time step.

        Returns
        -------
        bool
            True if collision occurred, False otherwise
        """
        veh_ids = self.master_kernel.vehicle.get_ids()
        for veh in veh_ids:
            headway = self.master_kernel.vehicle.get_headway(veh)
            if headway <= 0:
                return True
            else:
                return False

    def close(self):
        """Closes the current simulation instance."""
        # Stop simulation
        order = 1  # 1: Cancel simulation
        when = int(self.kernel_api.AKIGetCurrentSimulationTime())  # sim time
        self.kernel_api.ANGSetSimulationOrder(order, when)

        # Save and close the network
        gui = GKGUISystem.getGUISystem().getActiveGui()
        model = gui.getActiveModel()
        gui.save()  # TODO this can be saveAs depending on the template
        gui.closeDocument(model)

        # Quit the GUI
        gui.forceQuit()

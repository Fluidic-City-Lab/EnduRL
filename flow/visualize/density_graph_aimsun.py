"""Plot density graph from Aimsun simulation on I-210

This method accepts as input the .sqlite file generated by Aimsun

To make sure the simulation generates this file, go in the scenario parameters
in Aimsun, in the "Outputs to Generate" tab

Make sure that "Statistics: Generate Time Series" and 
"Statistics: Store in Database" are checked, and configure the "Interval" of
saving (default: 00:10:00)

Then in "Store Locations", select a "Custom" database with a "SQLite" driver,
check the case "Create Database if the One Defined Does Not Exist"
and then choose where you want the database to be generated.

Finally, in "Statistics", make sure "Sections" is checked so that the table
"MI_SECT" is generated in the database.

Example usage
-----
::
    python density_graph_aimsun.py </path/to/file>.sqlite
        [optionally other paths if you want them to be plotted simultaneously]
"""

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.colors import BoundaryNorm
from matplotlib.ticker import MaxNLocator
import numpy as np
import sqlite3
import argparse


# IDs of sections on main I-210 highway
# ordered list of segments, each segment being a list of section IDs
# the first ID is the main section, the other ones are usually side
# lanes (eg HOV lanes)

# from West to East
i210_section_ids_l2r = [
    [8009297,8009300],
    [7633314],
    [8009307],
    [21575,8008877],
    [22453,8008880],
    [22435,8008883],
    [21598,8008887],
    [21602,8004006],
    [21610,21614,21591],
    [8015788],
    [21618],
    [8015785,21652],
    [21651,8016318],
    [8004245,21664,8008896],
    [21668,8008899],
    [21673,21657],
    [21677],
    [21681,8008902],
    [21686,8008905],
    [21690,21682],
    [21700],
    [21710,8009118],
    [21711,8008908],
    [21759,8008911],
    [21763,8008914],
    [21767,21697],
    [21755],
    [21774,8005457],
    [21787,8008917],
    [21799,8008920],
    [21803,8008870,8008923],
    [21811,8008926],
    [21822,8003955],
    [21831,8008929],
    [21860,8008932],
    [21875,21781],
    [21879],
    [21886,8008935],
    [8014955,8008864],
    [21891,8008938],
    [22029,21887],
    [22032],
    [22036,8008941],
    [22041,8003964],
    [22072,8008944],
    [22076,8008947],
    [8009533,8003973],
    [22080],
    [22417,8008950],
    [22421,8008953],
    [22425,8008956],
    [22106,22037],
    [22101],
    [22378,22387,8008959],
    [8006440,8008962],
    [22363,8003997],
    [22359,8003994],
    [22167,8008965],
    [22200,8008968],
    [22198,22169],
    [22172],
    [7992606,8003979],
    [22175,8008971],
    [7603458,22176,7996414],
    [8005419,8008974],
    [7996274,7996411],
    [7603424,8008977],
    [7603407,7603405],
    [7603387],
    [7603370,8003985],
    [7603362,8008980],
    [8009479,7603257,7996420],
    [7603258,7603273],
    [7603271],
    [7603262,8008983],
    [7603243,8008986],
    [7603244,8008989],
    [7603248,8008992],
    [7603253,7603266],
]

# from East to West
i210_section_ids_r2l = [
    [7603297],
    [7603278],
    [7603279],
    [7603308],
    [8016038],
    [7603289],
    [7603290],
    [7603349],
    [8016044],
    [7603366],
    [7603375],
    [7603394],
    [7603414],
    [7996280],
    [7996277],
    [7992629],
    [7996426],
    [7603464],
    [7603439],
    [22183],
    [22180],
    [8017156],
    [22188],
    [22190],
    [22168],
    [22347],
    [7824807],
    [8017148],
    [22367],
    [22383],
    [22379],
    [22100],
    [22102],
    [22398],
    [22402],
    [22406],
    [22410],
    [22089],
    [22088],
    [22084],
    [22054],
    [22049],
    [22046],
    [8016041],
    [8008861],
    [21902],
    [21897],
    [21895],
    [21917],
    [21871],
    [21864],
    [21858],
    [21842],
    [21835],
    [21815],
    [21795],
    [21791],
    [21751],
    [21777],
    [21747],
    [21745],
    [21736],
    [21731],
    [21725],
    [21718],
    [8016075],
    [21645],
    [8008823],
    [21641],
    [8014968],
    [8014887],
    [8014965],
    [21630],
    [21629],
    [21622],
    [21582],
    [21577],
    [21576],
    [22432],
    [22448],
    [7996917],
    [23280]
]


def plot(data_path, section_ids, replication_id,
         plot_cols, plot_rows, plot_count, plot_title):
    
    # retrieve simulation data
    # oid: section_id
    # ent: time step
    # sid: vehicle type (0 to get all types)
    # did: replication id
    query = "SELECT oid, ent, density FROM MISECT " + \
            "WHERE sid=0 AND did=" + str(replication_id) + " " + \
            "ORDER BY oid, ent" 
    conn = sqlite3.connect(data_path)
    c = conn.cursor()
    c.execute(query)
    data = c.fetchall()

    # turn data into map { section_id => list of densities ordered by increasing time }
    densities = {}
    for i in range(len(data)):
        section_id = data[i][0]
        time_step = data[i][1]
        density = data[i][2]
        if time_step == 0:
            densities[section_id] = [density]
        else:
            densities[section_id].append(density)

    # get number of sections and time steps
    n_segments = len(section_ids)
    n_time_steps = len(list(densities.values())[0])

    # compute density map
    y_map, x_map = np.mgrid[slice(1, n_segments + 1, 1),
                            slice(1, n_time_steps + 1, 1)]
    z_map = np.zeros((n_segments, n_time_steps))

    for x in range(n_segments):
        for t in range(n_time_steps):
            s_id = section_ids[x][0]
            z_map[x][t] = densities[s_id][t]

    # plot simulation data
    plt.subplot(plot_rows, plot_cols, plot_count)

    levels = MaxNLocator(nbins=15).tick_values(z_map.min(), z_map.max())
    cmap = plt.get_cmap('jet')
    cf = plt.contourf(x_map, y_map, z_map, levels=levels, cmap=cmap)
    cbar = plt.colorbar(cf)

    # add legend
    plt.title(plot_title)  
    plt.xlabel("Time")
    plt.ylabel("Space")
    cbar.set_label("Density")


def create_parser():

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='[Flow] Plots density chart generated by an Aimsun '
                    'simulation (data located in an *.sqlite file).')

    parser.add_argument('file', type=str, help='Path to the .sqlite file.')
    parser.add_argument(
        'additional_files', type=str, nargs='*', 
        help='Optional additional paths to .sqlite files.')

    return parser


if __name__ == '__main__':
    parser = create_parser()
    args = parser.parse_args()

    files = [arg.file] + arg.additional_files

    fig = plt.figure()

    replication_id = 8029577  # TODO generalize

    for i, path in enumerate(files):
        plot(path, i210_section_ids_l2r, replication_id,
            len(files), 2, i*2+1, "Density on I-210 highway from West to East")
        plot(path, i210_section_ids_l2r, replication_id,
            len(files), 2, i*2+2, "Density on I-210 highway from East to West")

    plt.show()

